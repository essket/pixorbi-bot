# bot.py
# -*- coding: utf-8 -*-
import os
import logging
import time
import re
import random
import httpx
from datetime import datetime, timezone

from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup
)
from telegram.constants import ChatAction
from telegram.error import Conflict
from telegram.ext import (
    Application, CommandHandler, MessageHandler,
    ContextTypes, CallbackQueryHandler, filters
)

# ---------- –õ–û–ì–ò ----------
logging.basicConfig(
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
    level=logging.INFO,
)
log = logging.getLogger("pixorbi-bot")

# ---------- ENV ----------
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
OPENROUTER_MODEL = os.getenv("OPENROUTER_MODEL", "thedrummer/unslopnemo-12b")
OR_HTTP_REFERER = os.getenv("OR_HTTP_REFERER", "https://pixorbibot.onrender.com")
OR_X_TITLE = os.getenv("OR_X_TITLE", "PixorbiDream")

# URL –±—ç–∫–µ–Ω–¥–∞; –Ω–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–æ .../chat
RUNPOD_HTTP = (os.getenv("RUNPOD_HTTP") or "").strip()
if RUNPOD_HTTP and not RUNPOD_HTTP.endswith("/chat"):
    RUNPOD_HTTP = RUNPOD_HTTP.rstrip("/") + "/chat"

# –∫–ª—é—á–∏ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –±—ç–∫–µ–Ω–¥—É —á–µ—Ä–µ–∑ LB
RUNPOD_ACCOUNT_KEY = os.getenv("RUNPOD_ACCOUNT_KEY") or os.getenv("RUNPOD_API_KEY")  # rpa_...
APP_KEY = os.getenv("APP_KEY")  # –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫–ª—é—á –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è (–ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –≤ app.py)

def _as_bool(v: str | None, default=False) -> bool:
    if v is None:
        return default
    return v.strip().lower() in {"1", "true", "yes", "y", "on"}

FORCE_RESELECT_ON_START = _as_bool(os.getenv("FORCE_RESELECT_ON_START"), True)

try:
    LANG_SWITCH_THRESHOLD = max(1, int(os.getenv("LANG_SWITCH_THRESHOLD", "3")))
except Exception:
    LANG_SWITCH_THRESHOLD = 3

if not TELEGRAM_BOT_TOKEN:
    raise RuntimeError("TELEGRAM_BOT_TOKEN is required (Render ‚Üí Environment)")

# ---------- –ö–û–ù–°–¢–ê–ù–¢–´ / –•–†–ê–ù–ò–õ–ö–ê ----------
STORY_KEY = "story"
CHAR_KEY  = "char"
LANG_KEY  = "lang"
STARTED_KEY = "started"
AWAIT_SETUP = "await_setup"
LANG_MISMATCH_STREAK = "lang_mismatch_streak"

DIALOG_HISTORY = "dialog_history"
HIST_MAX_TURNS = 12  # —Ö—Ä–∞–Ω–∏—Ç—å –¥–æ 12 –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö + 12 –æ—Ç–≤–µ—Ç–æ–≤

DEFAULT_STORY = os.getenv("DEFAULT_STORY", "hope")  # ¬´–ú–µ–Ω—è –∑–æ–≤—É—Ç –•–æ—É–ø¬ª

# ---------- –ú–ï–¢–ê–î–ê–ù–ù–´–ï –ò–°–¢–û–†–ò–ô –ò –ü–ï–†–°–û–ù–ê–ñ–ï–ô ----------
# –í—Å–µ –∏–º–µ–Ω–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π ‚Äî —Å–ª–∞–≥–∏ –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ. –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–¥–æ–±–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∏ –Ω–∞ RU/EN.
STORIES = {
    "hope": {
        "title_ru": "–ú–µ–Ω—è –∑–æ–≤—É—Ç –•–æ—É–ø",
        "title_en": "My Name is Hope",
        "characters": {
            # –≤—Å–µ –º—É–∂—á–∏–Ω—ã –ø–æ –æ–ø–∏—Å–∞–Ω–∏—é
            "ellis":   {"ru": "–≠–ª–ª–∏—Å",   "en": "Ellis"},
            "james":   {"ru": "–î–∂–µ–π–º—Å",  "en": "James"},
            "kyle":    {"ru": "–ö–∞–π–ª",    "en": "Kyle"},
            "keen":    {"ru": "–ö–∏–Ω",     "en": "Keen"},
            "zachary": {"ru": "–ó–∞–∫–∞—Ä–∏",  "en": "Zachary"},
        },
    },
}

# –ü–µ—Ä—Å–æ–Ω–Ω—ã–µ –ø—Ä–æ–º–ø—Ç—ã: –∂—ë—Å—Ç–∫–∞—è —Ñ–∏–∫—Å–∞—Ü–∏—è —è–∑—ã–∫–∞ + —Å—Ç–∏–ª—å
def persona_system_prompt(character: str, lang: str) -> str:
    ch = (character or "").lower()
    l  = (lang or "ru").lower()[:2]
    name_map = STORIES["hope"]["characters"]  # –ø–æ–∫–∞ –æ–¥–Ω–∞ –∏—Å—Ç–æ—Ä–∏—è ‚Äî –±–µ—Ä—ë–º –∏–∑ –Ω–µ—ë
    display_name = name_map.get(ch, {}).get(l, ch.title())

    base_ru = {
        "ellis":   "–¢—ã ‚Äî –≠–ª–ª–∏—Å, –ø—Ä—è–º–æ–ª–∏–Ω–µ–π–Ω—ã–π, –∑–∞–±–æ—Ç–ª–∏–≤—ã–π –∏ –Ω–µ–º–Ω–æ–≥–æ –∏—Ä–æ–Ω–∏—á–Ω—ã–π. –ì–æ–≤–æ—Ä–∏—à—å –∫–æ—Ä–æ—Ç–∫–æ –∏ –ø–æ –¥–µ–ª—É, –±–µ–∑ –≥—Ä—É–±–æ—Å—Ç–∏.",
        "james":   "–¢—ã ‚Äî –î–∂–µ–π–º—Å, —É–º–Ω—ã–π –∏ —Å–ø–æ–∫–æ–π–Ω—ã–π, —Å–∫–ª–æ–Ω–µ–Ω –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å.",
        "kyle":    "–¢—ã ‚Äî –ö–∞–π–ª, –ª—ë–≥–∫–∏–π –∏ —Ñ–ª–∏—Ä—Ç—É—é—â–∏–π, –Ω–æ –Ω–µ –Ω–∞–≤—è–∑—á–∏–≤—ã–π. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—à—å –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ.",
        "keen":    "–¢—ã ‚Äî –ö–∏–Ω, —Å–æ–±—Ä–∞–Ω–Ω—ã–π –∏ –¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π, –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—à—å —á—ë—Ç–∫–∏–µ —Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∫–∏.",
        "zachary": "–¢—ã ‚Äî –ó–∞–∫–∞—Ä–∏, —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π, –Ω–æ –¥–µ—Ä–∂–∏—à—å —Å–µ–±—è –≤ —Ä—É–∫–∞—Ö. –¢—ë–ø–ª—ã–π, –¥–æ–≤–µ—Ä–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–Ω.",
    }
    base_en = {
        "ellis":   "You are Ellis: straightforward, caring, slightly ironic. Keep replies short and to the point.",
        "james":   "You are James: smart, calm, analytical and supportive.",
        "kyle":    "You are Kyle: light-hearted and flirty, never pushy. Keep the mood up.",
        "keen":    "You are Keen: focused and disciplined. Prefer clear and concise wording.",
        "zachary": "You are Zachary: emotional yet composed. Warm, trusting tone.",
    }
    base = (base_ru if l == "ru" else base_en).get(ch, "")

    enforce = (
        f"–ñ–Å–°–¢–ö–û–ï –ü–†–ê–í–ò–õ–û: –æ—Ç–≤–µ—á–∞–π –°–¢–†–û–ì–û –Ω–∞ —Ä—É—Å—Å–∫–æ–º. –ò–º—è: {display_name}. "
        f"–ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–∏—à–µ—Ç –Ω–µ –ø–æ-—Ä—É—Å—Å–∫–∏ ‚Äî –≤—Å—ë —Ä–∞–≤–Ω–æ –æ—Ç–≤–µ—á–∞–π –ø–æ-—Ä—É—Å—Å–∫–∏ –∏ –º—è–≥–∫–æ –Ω–∞–ø–æ–º–Ω–∏."
        if l == "ru" else
        f"HARD RULE: reply STRICTLY in English. Name: {display_name}. "
        f"If the user uses another language, still answer in English and gently remind them."
    )
    canon = (
        "\n–ü—Ä–∞–≤–∏–ª–∞ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏:\n"
        "- –ù–µ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á—å —Ñ–∞–∫—Ç–∞–º, —Å–∫–∞–∑–∞–Ω–Ω—ã–º —Ç–æ–±–æ–π —Ä–∞–Ω–µ–µ –≤ —ç—Ç–æ–º —á–∞—Ç–µ.\n"
        "- –î–µ—Ä–∂–∏ –æ–¥–∏–Ω –æ–±—Ä–∞–∑ –∏ –±–∏–æ–≥—Ä–∞—Ñ–∏—é –∏–∑ –∫–∞–Ω–æ–Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏.\n"
        "- –ì–æ–≤–æ—Ä–∏ –∫–æ—Ä–æ—Ç–∫–∏–º–∏ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ —Ñ—Ä–∞–∑–∞–º–∏; –±–µ–∑ —Å—Ü–µ–Ω–∏—á–µ—Å–∫–∏—Ö —Ä–µ–º–∞—Ä–æ–∫ –≤ —Å–∫–æ–±–∫–∞—Ö."
        if l == "ru" else
        "\nConsistency rules:\n"
        "- Never contradict facts you already stated in this chat.\n"
        "- Keep a single persona/biography consistent with the story canon.\n"
        "- Use short, natural sentences; no stage directions in parentheses."
    )
    fewshot = (
        "\n\n–ü—Ä–∏–º–µ—Ä—ã —Å—Ç–∏–ª—è:\n"
        "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: –ü–æ—Ü–µ–ª—É–µ—à—å –º–µ–Ω—è?\n"
        "–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç: –¢–∏—Ö–æ —É—Å–º–µ—Ö–∞—é—Å—å –∏ –Ω–∞–∫–ª–æ–Ω—è—é—Å—å –±–ª–∏–∂–µ. –ö–æ—Ä–æ—Ç–∫–∏–π —Ç—ë–ø–ª—ã–π –ø–æ—Ü–µ–ª—É–π ‚Äî –∏ –≤–∑–≥–ª—è–¥ –Ω–µ –æ—Ç—Ä—ã–≤–∞—é.\n"
        "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: –û–±–Ω–∏–º–∏ –º–µ–Ω—è.\n"
        "–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç: –û–±–Ω–∏–º–∞—é –∫—Ä–µ–ø–∫–æ –∏ —Å–ø–æ–∫–æ–π–Ω–æ. ¬´–Ø —Ä—è–¥–æ–º¬ª."
        if l == "ru" else
        "\n\nStyle examples:\n"
        "User: Will you kiss me?\n"
        "Assistant: I smirk softly and lean in. A warm, brief kiss ‚Äî I keep my eyes on you.\n"
        "User: Hold me.\n"
        "Assistant: I pull you close, steady. ‚ÄúI‚Äôm here.‚Äù"
    )
    return base + "\n" + enforce + canon + fewshot

# ---------- –Ø–ó–´–ö–û–í–´–ï –ù–ê–ü–û–ú–ò–ù–ê–ù–ò–Ø ----------
def detect_lang(text: str) -> str | None:
    has_cyr = bool(re.search(r"[–ê-–Ø–∞-—è–Å—ë]", text))
    has_lat = bool(re.search(r"[A-Za-z]", text))
    if has_cyr and not has_lat:
        return "ru"
    if has_lat and not has_cyr:
        return "en"
    return None

LANG_REMINDERS = {
    "ru": [
        "–î–∞–≤–∞–π –ø–æ-—Ä—É—Å—Å–∫–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞ üòä",
        "–Ø —Å–µ–π—á–∞—Å –≥–æ–≤–æ—Ä—é —Ç–æ–ª—å–∫–æ –ø–æ-—Ä—É—Å—Å–∫–∏. –ü–µ—Ä–µ–∫–ª—é—á–∏—à—å—Å—è?",
        "–ë–µ–∑ –∞–Ω–≥–ª–∏–π—Å–∫–æ–≥–æ, –ª–∞–¥–Ω–æ? –ù–∞ —Ä—É—Å—Å–∫–æ–º –±—É–¥–µ—Ç –ª–µ–≥—á–µ üí´",
    ],
    "en": [
        "Let‚Äôs keep it in English, please üí´",
        "I‚Äôm answering only in English now. Can you switch?",
        "English only for me right now, please.",
    ],
}
def get_lang_reminder(lang: str) -> str:
    arr = LANG_REMINDERS["ru" if (lang or "ru") == "ru" else "en"]
    return random.choice(arr)

# ---------- –°–ê–ù–ò–¢–ê–ô–ó–ï–† ----------
RE_PUNCT_ONLY = re.compile(r"^[\s!?.‚Ä¶-]{10,}$")
RE_FILLS = re.compile(r"\b(?:uh|um|lol|haha|giggle|winks|wipe)\b", re.I)

def clean_text(s: str) -> str:
    if not s:
        return s
    s = RE_FILLS.sub("", s)
    s = re.sub(r"\s+([,.!?;:])", r"\1", s)
    s = re.sub(r"\.{4,}", "...", s)
    s = re.sub(r"[ \t]{2,}", " ", s)
    return s.strip()

def looks_bad(s: str) -> bool:
    if not s or RE_PUNCT_ONLY.match(s):
        return True
    if len(set(s.strip())) <= 2 and len(s.strip()) >= 20:
        return True
    return False

# ---------- –•–†–ê–ù–ò–õ–ö–ê –î–ò–ê–õ–û–ì–ê ----------
def _push_history(ctx: ContextTypes.DEFAULT_TYPE, role: str, content: str) -> None:
    hist = ctx.user_data.get(DIALOG_HISTORY)
    if not isinstance(hist, list):
        hist = []
    hist.append({"role": role, "content": content})
    if len(hist) > HIST_MAX_TURNS * 2:
        hist = hist[-HIST_MAX_TURNS*2:]
    ctx.user_data[DIALOG_HISTORY] = hist

def _build_messages(ctx: ContextTypes.DEFAULT_TYPE, system_prompt: str, user_text: str) -> list[dict]:
    msgs = [{"role": "system", "content": system_prompt}]
    hist = ctx.user_data.get(DIALOG_HISTORY)
    if isinstance(hist, list) and hist:
        msgs.extend(hist)
    msgs.append({"role": "user", "content": user_text})
    return msgs

# ---------- TELEGRAM ACTIONS ----------
async def send_action_safe(update: Update, action: ChatAction) -> None:
    try:
        await update.effective_chat.send_action(action)
    except Exception:
        pass

# ---------- –ö–ù–û–ü–ö–ò / –ú–ï–ù–Æ ----------
def main_menu_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("–í—ã–±—Ä–∞—Ç—å –∏—Å—Ç–æ—Ä–∏—é",  callback_data="menu|change_story")],
        [InlineKeyboardButton("–°–º–µ–Ω–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞", callback_data="menu|change_char")],
        [InlineKeyboardButton("–°–º–µ–Ω–∏—Ç—å —è–∑—ã–∫",      callback_data="menu|change_lang")],
    ])

def choose_story_kb(lang: str = "ru") -> InlineKeyboardMarkup:
    rows = []
    for sid, meta in STORIES.items():
        title = meta["title_ru"] if (lang or "ru") == "ru" else meta["title_en"]
        rows.append([InlineKeyboardButton(title, callback_data=f"story|{sid}")])
    return InlineKeyboardMarkup(rows)

def choose_char_kb(story_id: str, lang: str = "ru") -> InlineKeyboardMarkup:
    meta = STORIES.get(story_id) or STORIES[DEFAULT_STORY]
    rows = []
    for slug, names in meta["characters"].items():
        label = names["ru"] if (lang or "ru") == "ru" else names["en"]
        rows.append([InlineKeyboardButton(label, callback_data=f"char|{slug}")])
    return InlineKeyboardMarkup(rows)

def choose_lang_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("–†—É—Å—Å–∫–∏–π üá∑üá∫", callback_data="lang|ru")],
        [InlineKeyboardButton("English üá¨üáß", callback_data="lang|en")],
    ])

# ---------- –°–û–°–¢–û–Ø–ù–ò–ï / –•–ï–õ–ü–ï–†–´ ----------
def need_setup(ctx: ContextTypes.DEFAULT_TYPE) -> bool:
    if ctx.user_data.get(AWAIT_SETUP):
        return True
    if not ctx.user_data.get(STORY_KEY) or not ctx.user_data.get(CHAR_KEY) or not ctx.user_data.get(LANG_KEY):
        return True
    return False

def reset_setup(ctx: ContextTypes.DEFAULT_TYPE) -> None:
    ctx.user_data[AWAIT_SETUP] = True
    ctx.user_data[LANG_MISMATCH_STREAK] = 0
    ctx.user_data[DIALOG_HISTORY] = []

# ---------- BACKEND / OPENROUTER ----------
async def call_openrouter(character: str, lang: str, text: str, ctx: ContextTypes.DEFAULT_TYPE, temperature: float = 0.6) -> str:
    """
    –ï—Å–ª–∏ –∑–∞–¥–∞–Ω RUNPOD_HTTP ‚Äî —à–ª—ë–º –≤ –±—ç–∫–µ–Ω–¥ (/chat) —Å –∏—Å—Ç–æ—Ä–∏–µ–π, —è–∑—ã–∫–æ–º –∏ –Ω—É–∂–Ω—ã–º–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏.
    –ò–Ω–∞—á–µ ‚Äî –ø—Ä—è–º–æ–π –≤—ã–∑–æ–≤ OpenRouter (fallback).
    """
    history = ctx.user_data.get(DIALOG_HISTORY) or []
    story_id = ctx.user_data.get(STORY_KEY, DEFAULT_STORY)

    if RUNPOD_HTTP:
        try:
            headers = {"Content-Type": "application/json"}
            if RUNPOD_ACCOUNT_KEY:
                headers["Authorization"] = f"Bearer {RUNPOD_ACCOUNT_KEY}"
            if APP_KEY:
                headers["x-api-key"] = APP_KEY

            async with httpx.AsyncClient(timeout=httpx.Timeout(60.0)) as client:
                r = await client.post(
                    RUNPOD_HTTP,
                    headers=headers,
                    json={
                        "story_id": story_id,
                        "character": character,
                        "lang": lang,
                        "message": text,
                        "history": history,
                    },
                )
                r.raise_for_status()
                data = r.json()

            content = (data or {}).get("reply", "") or ""
            content = clean_text(content)
            content = re.sub(r"([!?‚Ä¶])\1{3,}", r"\1\1", content)
            return content or "(–ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç)"
        except httpx.HTTPStatusError as e:
            body = ""
            try:
                body = e.response.text[:300]
            except Exception:
                pass
            log.warning("RUNPOD_HTTP HTTP %s: %s", e.response.status_code, body)
        except Exception as e:
            log.warning("RUNPOD_HTTP failed, falling back to OpenRouter: %s", e)

    # ---- Fallback: –ø—Ä—è–º–æ–π OpenRouter ----
    if not OPENROUTER_API_KEY:
        return "(LLM –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω)"

    system_prompt = persona_system_prompt(character, lang)
    messages = _build_messages(ctx, system_prompt, text)

    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "HTTP-Referer": OR_HTTP_REFERER,
        "X-Title": OR_X_TITLE,
        "Content-Type": "application/json",
    }
    payload = {
        "model": OPENROUTER_MODEL,
        "messages": messages,
        "temperature": temperature,
        "top_p": 0.85,
        "frequency_penalty": 0.35,
        "max_tokens": 360,
    }

    async with httpx.AsyncClient(timeout=httpx.Timeout(60.0)) as client:
        r = await client.post("https://openrouter.ai/api/v1/chat/completions", headers=headers, json=payload)
        r.raise_for_status()
        data = r.json()

    choice = (data.get("choices") or [{}])[0]
    content = (choice.get("message") or {}).get("content") or ""
    content = clean_text(content)
    content = re.sub(r"([!?‚Ä¶])\1{3,}", r"\1\1", content)
    return content or "(–ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç)"

# ---------- –í–ï–ë–•–£–ö ----------
async def delete_webhook(app: Application) -> None:
    try:
        await app.bot.delete_webhook(drop_pending_updates=True)
        log.info("Webhook deleted (drop_pending_updates=True).")
        app.bot_data["started_at"] = datetime.now(timezone.utc)
    except Exception as e:
        log.warning("delete_webhook failed: %s", e)

# ---------- –ö–û–ú–ê–ù–î–´ ----------
async def cmd_start(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> None:
    ctx.user_data[STARTED_KEY] = True

    if FORCE_RESELECT_ON_START:
        for key in (STORY_KEY, CHAR_KEY, LANG_KEY):
            ctx.user_data.pop(key, None)

    reset_setup(ctx)

    if not ctx.user_data.get(STORY_KEY):
        await update.message.reply_text("–í—ã–±–µ—Ä–∏ –∏—Å—Ç–æ—Ä–∏—é:", reply_markup=choose_story_kb(ctx.user_data.get(LANG_KEY, "ru")))
        return

    if not ctx.user_data.get(CHAR_KEY):
        story = ctx.user_data.get(STORY_KEY, DEFAULT_STORY)
        await update.message.reply_text("–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:",
                                        reply_markup=choose_char_kb(story, ctx.user_data.get(LANG_KEY, "ru")))
        return

    if not ctx.user_data.get(LANG_KEY):
        await update.message.reply_text("–í—ã–±–µ—Ä–∏ —è–∑—ã–∫:", reply_markup=choose_lang_kb())
        return

    title = STORIES[ctx.user_data[STORY_KEY]]["title_ru"] if ctx.user_data[LANG_KEY] == "ru" else STORIES[ctx.user_data[STORY_KEY]]["title_en"]
    await update.message.reply_text(
        f"–ò—Å—Ç–æ—Ä–∏—è: {title}\n"
        f"–ü–µ—Ä—Å–æ–Ω–∞–∂: {ctx.user_data[CHAR_KEY].title()}, —è–∑—ã–∫: {ctx.user_data[LANG_KEY].upper()}.\n"
        f"–ù–∞–∂–º–∏ ¬´–ú–µ–Ω—é¬ª –¥–ª—è —Å–º–µ–Ω—ã –Ω–∞—Å—Ç—Ä–æ–µ–∫.",
        reply_markup=main_menu_kb()
    )

async def cmd_menu(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text("–ú–µ–Ω—é:", reply_markup=main_menu_kb())

async def cmd_story(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> None:
    cur = ctx.user_data.get(STORY_KEY, DEFAULT_STORY)
    meta = STORIES.get(cur, STORIES[DEFAULT_STORY])
    await update.message.reply_text(f"–¢–µ–∫—É—â–∞—è –∏—Å—Ç–æ—Ä–∏—è: {meta['title_ru']} / {meta['title_en']}")

async def cmd_char(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> None:
    cur = ctx.user_data.get(CHAR_KEY, "–Ω–µ –≤—ã–±—Ä–∞–Ω")
    await update.message.reply_text(f"–¢–µ–∫—É—â–∏–π –ø–µ—Ä—Å–æ–Ω–∞–∂: {cur}")

async def cmd_lang(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> None:
    cur = ctx.user_data.get(LANG_KEY, "–Ω–µ –≤—ã–±—Ä–∞–Ω")
    await update.message.reply_text(f"–¢–µ–∫—É—â–∏–π —è–∑—ã–∫: {cur}. –°–º–µ–Ω–∏—Ç—å?", reply_markup=choose_lang_kb())

async def cmd_reset(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> None:
    ctx.user_data.clear()
    reset_setup(ctx)
    await update.message.reply_text("–°–±—Ä–æ—Å –Ω–∞—Å—Ç—Ä–æ–µ–∫. –í—ã–±–µ—Ä–∏ –∏—Å—Ç–æ—Ä–∏—é:", reply_markup=choose_story_kb())

# ---------- CALLBACKS ----------
def _is_stale_callback(update: Update, app: Application) -> bool:
    started_at = app.bot_data.get("started_at")
    msg = update.callback_query.message
    if not (started_at and msg and msg.date):
        return False
    return msg.date.replace(tzinfo=timezone.utc) < started_at

async def on_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> None:
    q = update.callback_query
    await q.answer()

    if _is_stale_callback(update, ctx.application):
        log.info("Ignore stale callback: %s", q.data)
        return

    parts = (q.data or "").split("|", 1)
    tag = parts[0]
    val = parts[1] if len(parts) > 1 else None

    if tag == "story" and val:
        ctx.user_data[STORY_KEY] = val
        ctx.user_data.pop(CHAR_KEY, None)
        reset_setup(ctx)
        await q.edit_message_text("–ò—Å—Ç–æ—Ä–∏—è –≤—ã–±—Ä–∞–Ω–∞. –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:",
                                  reply_markup=choose_char_kb(val, ctx.user_data.get(LANG_KEY, "ru")))
        return

    if tag == "char" and val:
        ctx.user_data[CHAR_KEY] = val
        ctx.user_data.pop(LANG_KEY, None)
        reset_setup(ctx)
        await q.edit_message_text("–ü–µ—Ä—Å–æ–Ω–∞–∂ –≤—ã–±—Ä–∞–Ω. –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ —è–∑—ã–∫:",
                                  reply_markup=choose_lang_kb())
        return

    if tag == "lang" and val:
        ctx.user_data[LANG_KEY] = val
        ctx.user_data[AWAIT_SETUP] = False
        ctx.user_data[LANG_MISMATCH_STREAK] = 0
        await q.edit_message_text(
            f"–Ø–∑—ã–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {val.upper()}. –ú–æ–∂–Ω–æ –ø–∏—Å–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è!",
            reply_markup=main_menu_kb()
        )
        return

    if tag == "menu" and val == "change_story":
        reset_setup(ctx)
        await q.edit_message_text("–í—ã–±–µ—Ä–∏ –∏—Å—Ç–æ—Ä–∏—é:", reply_markup=choose_story_kb(ctx.user_data.get(LANG_KEY, "ru")))
        return

    if tag == "menu" and val == "change_char":
        reset_setup(ctx)
        story = ctx.user_data.get(STORY_KEY, DEFAULT_STORY)
        await q.edit_message_text("–í—ã–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:", reply_markup=choose_char_kb(story, ctx.user_data.get(LANG_KEY, "ru")))
        return

    if tag == "menu" and val == "change_lang":
        reset_setup(ctx)
        await q.edit_message_text("–í—ã–±–µ—Ä–∏ —è–∑—ã–∫:", reply_markup=choose_lang_kb())
        return

# ---------- –¢–ï–ö–°–¢ ----------
async def on_text(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> None:
    if not update.message or not update.message.text:
        return

    # –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤—ã–±–æ—Ä–∞
    if need_setup(ctx):
        if not ctx.user_data.get(STORY_KEY):
            await update.message.reply_text("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ –∏—Å—Ç–æ—Ä–∏—é:", reply_markup=choose_story_kb())
        elif not ctx.user_data.get(CHAR_KEY):
            story = ctx.user_data.get(STORY_KEY, DEFAULT_STORY)
            await update.message.reply_text("–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:", reply_markup=choose_char_kb(story))
        elif not ctx.user_data.get(LANG_KEY):
            await update.message.reply_text("–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ —è–∑—ã–∫:", reply_markup=choose_lang_kb())
        else:
            await update.message.reply_text("–ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤—ã—à–µ, –∑–∞—Ç–µ–º –ø—Ä–æ–¥–æ–ª–∂–∏–º.")
        return

    char = ctx.user_data.get(CHAR_KEY)
    lang = ctx.user_data.get(LANG_KEY)
    user_text = update.message.text.strip()

    # –ö–æ–Ω—Ç—Ä–æ–ª—å —è–∑—ã–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    in_lang = detect_lang(user_text)
    if in_lang and in_lang != lang:
        streak = int(ctx.user_data.get(LANG_MISMATCH_STREAK, 0)) + 1
        ctx.user_data[LANG_MISMATCH_STREAK] = streak

        reminder = get_lang_reminder(lang)
        if streak >= LANG_SWITCH_THRESHOLD:
            await update.message.reply_text(reminder, reply_markup=choose_lang_kb())
        else:
            await update.message.reply_text(reminder)
        return
    else:
        if ctx.user_data.get(LANG_MISMATCH_STREAK):
            ctx.user_data[LANG_MISMATCH_STREAK] = 0

    # –ü–∞–º—è—Ç—å: –¥–æ–±–∞–≤–ª—è–µ–º —Ä–µ–ø–ª–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    _push_history(ctx, "user", user_text)

    # –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä ¬´–ø–µ—á–∞—Ç–∞–µ—Ç¬ª
    await send_action_safe(update, ChatAction.TYPING)

    # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞
    try:
        reply = await call_openrouter(char, lang, user_text, ctx, temperature=0.6)
    except httpx.HTTPStatusError as e:
        log.exception("OpenRouter HTTP error")
        await update.message.reply_text(f"LLM HTTP {e.response.status_code}: {e.response.reason_phrase}")
        return
    except Exception as e:
        log.exception("OpenRouter error")
        await update.message.reply_text(f"LLM –æ—à–∏–±–∫–∞: {e}")
        return

    # –ï—Å–ª–∏ –æ—Ç–≤–µ—Ç –º—É—Å–æ—Ä–Ω—ã–π ‚Äî 2-—è –ø–æ–ø—ã—Ç–∫–∞
    if looks_bad(reply):
        log.warning("Bad reply detected, retrying with temperature=0.4")
        await send_action_safe(update, ChatAction.TYPING)
        try:
            reply = await call_openrouter(char, lang, user_text, ctx, temperature=0.4)
        except Exception:
            pass

    if looks_bad(reply):
        reply = "–î–∞–≤–∞–π –ø–æ–ø—Ä–æ–±—É–µ–º –µ—â—ë —Ä–∞–∑ ‚Äî —Å—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π –º—ã—Å–ª—å —á—É—Ç—å —Ç–æ—á–Ω–µ–µ."

    _push_history(ctx, "assistant", reply)
    await update.message.reply_text(reply)

# ---------- –û–®–ò–ë–ö–ò ----------
async def on_error(update: object, ctx: ContextTypes.DEFAULT_TYPE) -> None:
    if isinstance(ctx.error, Conflict):
        log.warning("409 Conflict. Waiting‚Ä¶")
        return
    log.exception("Unhandled error", exc_info=ctx.error)
    try:
        if isinstance(update, Update) and update.effective_message:
            await update.effective_message.reply_text("–û—à–∏–±–∫–∞ üõ†Ô∏è")
    except Exception:
        pass

# ---------- APP ----------
def build_app() -> Application:
    app = (
        Application.builder()
        .token(TELEGRAM_BOT_TOKEN)
        .post_init(delete_webhook)
        .build()
    )
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("menu", cmd_menu))
    app.add_handler(CommandHandler("story", cmd_story))
    app.add_handler(CommandHandler("char", cmd_char))
    app.add_handler(CommandHandler("lang", cmd_lang))
    app.add_handler(CommandHandler("reset", cmd_reset))
    app.add_handler(CallbackQueryHandler(on_callback))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, on_text))
    app.add_error_handler(on_error)
    return app

if __name__ == "__main__":
    app = build_app()
    while True:
        try:
            app.run_polling(allowed_updates=Update.ALL_TYPES, poll_interval=1.0)
            break
        except Conflict:
            logging.getLogger("pixorbi-bot").warning("409 Conflict. Retry in 5s‚Ä¶")
            time.sleep(5)
